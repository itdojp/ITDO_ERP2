"""
Test for api.v1.auth.login
Auto-generated by CC02 v39.0
Enhanced by Claude Code to provide functional test implementation
"""

from unittest.mock import Mock, patch

import pytest
from fastapi import status
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

from app.schemas.auth import TokenResponse
from tests.factories import create_test_user


class TestAuthLoginAPI:
    """Test cases for auth login API endpoint."""

    @pytest.fixture
    def test_user_data(self, db_session: Session):
        """Create test user data for authentication tests."""
        user = create_test_user(
            db_session,
            email="testuser@example.com",
            full_name="Test User",
            is_active=True,
        )
        # Set a known password for testing
        user.set_password("TestPassword123!")
        db_session.commit()

        return {
            "user": user,
            "email": "testuser@example.com",
            "password": "TestPassword123!",
        }

    def test_successful_login(
        self, client: TestClient, test_user_data, db_session: Session
    ):
        """Test successful user login with valid credentials."""
        # Given
        login_data = {
            "email": test_user_data["email"],
            "password": test_user_data["password"],
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_200_OK

        response_data = response.json()
        assert "access_token" in response_data
        assert "refresh_token" in response_data
        assert response_data["token_type"] == "bearer"
        assert "expires_in" in response_data

        # Verify tokens are non-empty strings
        assert isinstance(response_data["access_token"], str)
        assert len(response_data["access_token"]) > 0
        assert isinstance(response_data["refresh_token"], str)
        assert len(response_data["refresh_token"]) > 0

    def test_login_invalid_email(self, client: TestClient, test_user_data):
        """Test login with invalid email address."""
        # Given
        login_data = {
            "email": "nonexistent@example.com",
            "password": test_user_data["password"],
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

        response_data = response.json()
        assert response_data["detail"] == "Invalid authentication credentials"
        assert response_data["code"] == "AUTH001"

    def test_login_invalid_password(self, client: TestClient, test_user_data):
        """Test login with invalid password."""
        # Given
        login_data = {"email": test_user_data["email"], "password": "WrongPassword123!"}

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

        response_data = response.json()
        assert response_data["detail"] == "Invalid authentication credentials"
        assert response_data["code"] == "AUTH001"

    def test_login_inactive_user(self, client: TestClient, db_session: Session):
        """Test login with inactive user account."""
        # Given - create inactive user
        inactive_user = create_test_user(
            db_session, email="inactive@example.com", is_active=False
        )
        inactive_user.set_password("TestPassword123!")
        db_session.commit()

        login_data = {"email": "inactive@example.com", "password": "TestPassword123!"}

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

        response_data = response.json()
        assert response_data["detail"] == "Invalid authentication credentials"
        assert response_data["code"] == "AUTH001"

    def test_login_malformed_email(self, client: TestClient, test_user_data):
        """Test login with malformed email address."""
        # Given
        login_data = {
            "email": "not-an-email",  # Invalid email format
            "password": test_user_data["password"],
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

        response_data = response.json()
        assert "detail" in response_data
        # Pydantic validation error for invalid email format

    def test_login_empty_password(self, client: TestClient, test_user_data):
        """Test login with empty password."""
        # Given
        login_data = {
            "email": test_user_data["email"],
            "password": "",  # Empty password
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

        response_data = response.json()
        assert "detail" in response_data
        # Pydantic validation error for minimum length

    def test_login_missing_fields(self, client: TestClient):
        """Test login with missing required fields."""
        # Test missing email
        response = client.post("/api/v1/auth/login", json={"password": "test123"})
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

        # Test missing password
        response = client.post("/api/v1/auth/login", json={"email": "test@example.com"})
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

        # Test empty request body
        response = client.post("/api/v1/auth/login", json={})
        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

    @patch("app.services.auth.AuthService.authenticate_user")
    def test_login_auth_service_failure(
        self, mock_auth, client: TestClient, test_user_data
    ):
        """Test login when auth service returns None (authentication failed)."""
        # Given
        mock_auth.return_value = None

        login_data = {
            "email": test_user_data["email"],
            "password": test_user_data["password"],
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
        response_data = response.json()
        assert response_data["detail"] == "Invalid authentication credentials"
        assert response_data["code"] == "AUTH001"

    @patch("app.services.auth.AuthService.authenticate_user")
    @patch("app.services.auth.AuthService.create_tokens")
    def test_login_token_creation_success(
        self, mock_create_tokens, mock_auth, client: TestClient, test_user_data
    ):
        """Test successful token creation after authentication."""
        # Given
        mock_user = Mock()
        mock_user.id = 1
        mock_user.email = test_user_data["email"]
        mock_auth.return_value = mock_user

        mock_tokens = TokenResponse(
            access_token="test_access_token",
            refresh_token="test_refresh_token",
            token_type="bearer",
            expires_in=86400,
        )
        mock_create_tokens.return_value = mock_tokens

        login_data = {
            "email": test_user_data["email"],
            "password": test_user_data["password"],
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        assert response.status_code == status.HTTP_200_OK
        response_data = response.json()
        assert response_data["access_token"] == "test_access_token"
        assert response_data["refresh_token"] == "test_refresh_token"
        assert response_data["token_type"] == "bearer"
        assert response_data["expires_in"] == 86400

    def test_login_case_insensitive_email(self, client: TestClient, test_user_data):
        """Test login with different email case."""
        # Given - use uppercase email
        login_data = {
            "email": test_user_data["email"].upper(),
            "password": test_user_data["password"],
        }

        # When
        response = client.post("/api/v1/auth/login", json=login_data)

        # Then
        # This test assumes the system should handle case-insensitive emails
        # The actual behavior depends on your authentication implementation
        assert response.status_code in [
            status.HTTP_200_OK,
            status.HTTP_401_UNAUTHORIZED,
        ]

    def test_login_sql_injection_attempt(self, client: TestClient):
        """Test login endpoint security against SQL injection attempts."""
        # Given
        malicious_inputs = [
            "' OR '1'='1",
            "admin@example.com'; DROP TABLE users; --",
            "test@example.com' UNION SELECT * FROM users --",
        ]

        for malicious_email in malicious_inputs:
            login_data = {"email": malicious_email, "password": "password123"}

            # When
            response = client.post("/api/v1/auth/login", json=login_data)

            # Then - should either be validation error or auth failure, never success
            assert response.status_code in [
                status.HTTP_401_UNAUTHORIZED,
                status.HTTP_422_UNPROCESSABLE_ENTITY,
            ]


def test_login():
    """Legacy test function - kept for compatibility."""
    # This test is now covered by the class-based tests above
    assert True


def test_login_error_handling():
    """Legacy test function - kept for compatibility."""
    # Error handling is now covered by the class-based tests above
    assert True
