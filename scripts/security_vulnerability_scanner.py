#!/usr/bin/env python3
"""
CC02 v33.0 セキュリティ脆弱性スキャナー - Infinite Loop Cycle 4
Security Vulnerability Scanner for Comprehensive Security Analysis
"""

import re
import json
import hashlib
import base64
from pathlib import Path
from typing import Dict, List, Any, Optional, Set, Tuple
from datetime import datetime
from collections import defaultdict, Counter
from dataclasses import dataclass, asdict
import ast


@dataclass
class SecurityVulnerability:
    """セキュリティ脆弱性データクラス"""
    file_path: str
    line_number: int
    vulnerability_type: str
    severity: str
    cwe_id: str
    description: str
    recommendation: str
    code_snippet: str
    confidence: str


@dataclass
class SecurityMetrics:
    """セキュリティメトリクス"""
    total_files_scanned: int
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    info_count: int
    security_score: float
    compliance_status: str


class SecurityVulnerabilityScanner:
    """セキュリティ脆弱性スキャナー"""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.backend_path = project_root / "backend"
        self.output_path = project_root / "scripts" / "security_reports"
        self.output_path.mkdir(exist_ok=True)
        
        # OWASP Top 10 and common vulnerability patterns
        self.vulnerability_patterns = {
            # A01: Broken Access Control
            "broken_access_control": {
                "patterns": [
                    r"@app\.route\([^)]*\)(?!\s*@\w*auth)",  # Routes without auth decorators
                    r"if\s+.*\.is_admin\s*==\s*True",  # Hardcoded admin checks
                    r"session\[.user_id.\]\s*==\s*\d+",  # Direct user ID comparison
                ],
                "severity": "high",
                "cwe": "CWE-284",
                "description": "Potential broken access control vulnerability"
            },
            
            # A02: Cryptographic Failures
            "weak_cryptography": {
                "patterns": [
                    r"hashlib\.md5\(",  # Weak MD5 hashing
                    r"hashlib\.sha1\(",  # Weak SHA1 hashing
                    r"random\.random\(\)",  # Weak random for security
                    r"['\"]secret['\"]|['\"]password['\"]|['\"]key['\"]",  # Hardcoded secrets
                    r"base64\.b64encode\(.*password",  # Base64 encoding passwords
                ],
                "severity": "high",
                "cwe": "CWE-327",
                "description": "Weak cryptographic implementation detected"
            },
            
            # A03: Injection
            "sql_injection": {
                "patterns": [
                    r"execute\([^)]*\+[^)]*\)",  # SQL concatenation
                    r"\.format\(.*\).*execute",  # String formatting in SQL
                    r"f['\"].*{.*}.*['\"].*execute",  # F-string in SQL
                    r"session\.execute\(text\([^)]*\+",  # SQLAlchemy text concatenation
                ],
                "severity": "critical",
                "cwe": "CWE-89",
                "description": "Potential SQL injection vulnerability"
            },
            
            "command_injection": {
                "patterns": [
                    r"os\.system\([^)]*\+[^)]*\)",  # Command concatenation
                    r"subprocess\.call\([^)]*\+[^)]*\)",  # Subprocess concatenation
                    r"subprocess\.run\([^)]*shell=True",  # Shell execution
                    r"eval\([^)]*input\([^)]*\)",  # Eval with user input
                ],
                "severity": "critical",
                "cwe": "CWE-78",
                "description": "Potential command injection vulnerability"
            },
            
            # A04: Insecure Design
            "insecure_design": {
                "patterns": [
                    r"password.*=.*input\(",  # Password from user input
                    r"admin.*=.*True",  # Hardcoded admin flags
                    r"debug.*=.*True",  # Debug mode enabled
                    r"SECRET_KEY.*=.*['\"].*['\"]",  # Hardcoded secret keys
                ],
                "severity": "medium",
                "cwe": "CWE-657",
                "description": "Insecure design pattern detected"
            },
            
            # A05: Security Misconfiguration
            "security_misconfiguration": {
                "patterns": [
                    r"app\.run\(.*debug=True",  # Debug mode in production
                    r"CORS\(.*origins.*\*",  # Wildcard CORS
                    r"allow_credentials=True.*origins.*\*",  # Dangerous CORS config
                    r"SSL_VERIFY.*=.*False",  # SSL verification disabled
                ],
                "severity": "high",
                "cwe": "CWE-16",
                "description": "Security misconfiguration detected"
            },
            
            # A06: Vulnerable Components
            "vulnerable_components": {
                "patterns": [
                    r"import\s+pickle",  # Unsafe pickle usage
                    r"yaml\.load\((?!.*Loader=yaml\.SafeLoader)",  # Unsafe YAML loading
                    r"eval\(",  # Dangerous eval usage
                    r"exec\(",  # Dangerous exec usage
                ],
                "severity": "high",
                "cwe": "CWE-1104",
                "description": "Usage of vulnerable component detected"
            },
            
            # A07: Authentication Failures
            "authentication_failures": {
                "patterns": [
                    r"password.*==.*['\"].*['\"]",  # Hardcoded password comparison
                    r"login.*without.*authentication",  # Missing authentication
                    r"session.*timeout.*=.*None",  # No session timeout
                    r"remember_me.*=.*True",  # Insecure remember me
                ],
                "severity": "high",
                "cwe": "CWE-287",
                "description": "Authentication failure pattern detected"
            },
            
            # A08: Software Data Integrity Failures
            "data_integrity": {
                "patterns": [
                    r"urllib\.request\.urlopen\([^)]*http:",  # Unencrypted data fetching
                    r"requests\.get\([^)]*verify=False",  # Certificate verification disabled
                    r"download.*without.*checksum",  # No integrity check
                ],
                "severity": "medium",
                "cwe": "CWE-345",
                "description": "Data integrity issue detected"
            },
            
            # A09: Logging Failures
            "logging_failures": {
                "patterns": [
                    r"print\(.*password",  # Password in print statements
                    r"logger\.info\(.*password",  # Password in logs
                    r"log.*sensitive.*data",  # Sensitive data logging
                ],
                "severity": "medium",
                "cwe": "CWE-532",
                "description": "Sensitive information in logs detected"
            },
            
            # A10: Server-Side Request Forgery
            "ssrf": {
                "patterns": [
                    r"requests\.get\(.*user_input",  # User-controlled URLs
                    r"urllib\.request\.urlopen\(.*request\.",  # User-controlled requests
                    r"fetch\(.*params\.",  # User-controlled fetch
                ],
                "severity": "high",
                "cwe": "CWE-918",
                "description": "Potential SSRF vulnerability detected"
            }
        }
        
        # Additional security patterns
        self.additional_patterns = {
            "xss_vulnerabilities": {
                "patterns": [
                    r"render_template_string\([^)]*\+",  # Template injection
                    r"Markup\([^)]*\+[^)]*\)",  # Unsafe markup
                    r"\.innerHTML.*=.*request\.",  # XSS in templates
                ],
                "severity": "high",
                "cwe": "CWE-79",
                "description": "Cross-site scripting vulnerability detected"
            },
            
            "path_traversal": {
                "patterns": [
                    r"open\([^)]*\+.*\.\.",  # Path traversal in file operations
                    r"file_path.*=.*request\.",  # User-controlled file paths
                    r"os\.path\.join\(.*user_input",  # Unsafe path joining
                ],
                "severity": "high",
                "cwe": "CWE-22",
                "description": "Path traversal vulnerability detected"
            },
            
            "information_disclosure": {
                "patterns": [
                    r"app\.config\[.SECRET_KEY.\]",  # Secret key exposure
                    r"traceback\.print_exc\(\)",  # Stack trace exposure
                    r"app\.debug.*=.*True",  # Debug information exposure
                ],
                "severity": "medium",
                "cwe": "CWE-200",
                "description": "Information disclosure vulnerability detected"
            },
            
            "insufficient_logging": {
                "patterns": [
                    r"except.*:\s*pass",  # Silent exception handling
                    r"try:.*except.*:\s*continue",  # Ignored exceptions
                    r"login.*success.*without.*logging",  # No login logging
                ],
                "severity": "low",
                "cwe": "CWE-778",
                "description": "Insufficient logging detected"
            }
        }
        
        # Combine all patterns
        self.all_patterns = {**self.vulnerability_patterns, **self.additional_patterns}
        
        # File extensions to scan
        self.scan_extensions = {'.py', '.js', '.ts', '.html', '.sql', '.yaml', '.yml', '.json', '.cfg', '.ini'}
        
        # Sensitive file patterns
        self.sensitive_files = [
            r'.*\.key$',
            r'.*\.pem$',
            r'.*\.crt$',
            r'.*\.p12$',
            r'.*\.pfx$',
            r'.*config.*\.py$',
            r'.*settings.*\.py$',
            r'.*secrets.*\.(py|json|yaml)$',
            r'.*\.env$',
            r'.*\.env\..*$'
        ]
    
    def scan_for_vulnerabilities(self) -> Dict[str, Any]:
        """脆弱性スキャン実行"""
        print("🔒 Scanning for security vulnerabilities...")
        
        scan_results = {
            "scan_timestamp": datetime.now().isoformat(),
            "vulnerabilities": [],
            "sensitive_files": [],
            "metrics": None,
            "owasp_compliance": {},
            "recommendations": []
        }
        
        # Get all files to scan
        files_to_scan = self._get_files_to_scan()
        print(f"  📊 Scanning {len(files_to_scan)} files...")
        
        # Scan each file
        for file_path in files_to_scan:
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Skip empty files
                if not content.strip():
                    continue
                
                # Check for sensitive files
                if self._is_sensitive_file(file_path):
                    scan_results["sensitive_files"].append({
                        "file": str(file_path),
                        "risk_level": "high",
                        "description": "Potentially sensitive file detected"
                    })
                
                # Scan for vulnerabilities
                file_vulnerabilities = self._scan_file_content(content, file_path)
                scan_results["vulnerabilities"].extend(file_vulnerabilities)
                
            except Exception as e:
                print(f"Warning: Could not scan {file_path}: {e}")
        
        # Calculate metrics
        scan_results["metrics"] = self._calculate_security_metrics(scan_results["vulnerabilities"], len(files_to_scan))
        
        # Assess OWASP compliance
        scan_results["owasp_compliance"] = self._assess_owasp_compliance(scan_results["vulnerabilities"])
        
        # Generate recommendations
        scan_results["recommendations"] = self._generate_security_recommendations(scan_results)
        
        return scan_results
    
    def _get_files_to_scan(self) -> List[Path]:
        """スキャン対象ファイル取得"""
        files_to_scan = []
        
        # Scan backend directory
        for file_path in self.backend_path.glob("**/*"):
            if file_path.is_file() and file_path.suffix in self.scan_extensions:
                if not any(exclude in str(file_path) for exclude in ['__pycache__', '.git', 'migrations', 'node_modules']):
                    files_to_scan.append(file_path)
        
        # Also scan config files in project root
        for file_path in self.project_root.glob("*"):
            if file_path.is_file() and (file_path.suffix in self.scan_extensions or file_path.name.startswith('.')):
                files_to_scan.append(file_path)
        
        return files_to_scan
    
    def _is_sensitive_file(self, file_path: Path) -> bool:
        """機密ファイル判定"""
        file_str = str(file_path)
        return any(re.match(pattern, file_str, re.IGNORECASE) for pattern in self.sensitive_files)
    
    def _scan_file_content(self, content: str, file_path: Path) -> List[SecurityVulnerability]:
        """ファイル内容スキャン"""
        vulnerabilities = []
        lines = content.split('\n')
        
        # Scan with all vulnerability patterns
        for vuln_type, vuln_info in self.all_patterns.items():
            for pattern in vuln_info["patterns"]:
                matches = re.finditer(pattern, content, re.MULTILINE | re.IGNORECASE)
                
                for match in matches:
                    line_num = content[:match.start()].count('\n') + 1
                    
                    # Calculate confidence based on context
                    confidence = self._calculate_confidence(match, content, vuln_type)
                    
                    vulnerability = SecurityVulnerability(
                        file_path=str(file_path.relative_to(self.project_root)),
                        line_number=line_num,
                        vulnerability_type=vuln_type,
                        severity=vuln_info["severity"],
                        cwe_id=vuln_info["cwe"],
                        description=vuln_info["description"],
                        recommendation=self._get_vulnerability_recommendation(vuln_type),
                        code_snippet=lines[line_num - 1].strip() if line_num <= len(lines) else "",
                        confidence=confidence
                    )
                    
                    vulnerabilities.append(vulnerability)
        
        # Additional context-aware analysis
        vulnerabilities.extend(self._analyze_ast_vulnerabilities(content, file_path))
        
        return vulnerabilities
    
    def _calculate_confidence(self, match: re.Match, content: str, vuln_type: str) -> str:
        """信頼度計算"""
        # Basic confidence calculation based on context
        context_window = 200
        start = max(0, match.start() - context_window)
        end = min(len(content), match.end() + context_window)
        context = content[start:end].lower()
        
        # High confidence indicators
        high_confidence_indicators = ['password', 'secret', 'key', 'token', 'admin', 'root', 'execute', 'query']
        
        # Low confidence indicators
        low_confidence_indicators = ['test', 'example', 'demo', 'mock', 'fake', 'comment']
        
        high_count = sum(1 for indicator in high_confidence_indicators if indicator in context)
        low_count = sum(1 for indicator in low_confidence_indicators if indicator in context)
        
        if high_count >= 2:
            return "high"
        elif low_count >= 2:
            return "low"
        else:
            return "medium"
    
    def _analyze_ast_vulnerabilities(self, content: str, file_path: Path) -> List[SecurityVulnerability]:
        """AST分析による脆弱性検出"""
        vulnerabilities = []
        
        if not file_path.suffix == '.py':
            return vulnerabilities
        
        try:
            tree = ast.parse(content)
            
            # Check for dangerous function calls
            for node in ast.walk(tree):
                if isinstance(node, ast.Call):
                    if hasattr(node.func, 'id'):
                        func_name = node.func.id
                        
                        # Check for eval/exec usage
                        if func_name in ['eval', 'exec']:
                            vulnerabilities.append(SecurityVulnerability(
                                file_path=str(file_path.relative_to(self.project_root)),
                                line_number=node.lineno,
                                vulnerability_type="dangerous_function",
                                severity="critical",
                                cwe_id="CWE-95",
                                description=f"Dangerous {func_name}() function usage detected",
                                recommendation=f"Avoid using {func_name}(). Use safer alternatives like ast.literal_eval() for eval.",
                                code_snippet="",
                                confidence="high"
                            ))
                    
                    elif hasattr(node.func, 'attr'):
                        # Check for dangerous method calls
                        if hasattr(node.func.value, 'id'):
                            if node.func.value.id == 'os' and node.func.attr == 'system':
                                vulnerabilities.append(SecurityVulnerability(
                                    file_path=str(file_path.relative_to(self.project_root)),
                                    line_number=node.lineno,
                                    vulnerability_type="command_injection",
                                    severity="high",
                                    cwe_id="CWE-78",
                                    description="os.system() usage detected - potential command injection",
                                    recommendation="Use subprocess with proper input validation instead of os.system()",
                                    code_snippet="",
                                    confidence="high"
                                ))
        
        except SyntaxError:
            # Skip files with syntax errors
            pass
        
        return vulnerabilities
    
    def _get_vulnerability_recommendation(self, vuln_type: str) -> str:
        """脆弱性修正推奨事項"""
        recommendations = {
            "broken_access_control": "Implement proper access control with authentication decorators and role-based access control",
            "weak_cryptography": "Use strong cryptographic algorithms like bcrypt for passwords and AES-256 for encryption",
            "sql_injection": "Use parameterized queries or ORM methods to prevent SQL injection",
            "command_injection": "Use subprocess with shell=False and validate all user inputs",
            "insecure_design": "Follow security-by-design principles and implement proper authentication and authorization",
            "security_misconfiguration": "Review and harden security configurations, disable debug mode in production",
            "vulnerable_components": "Replace vulnerable components with secure alternatives",
            "authentication_failures": "Implement strong authentication with proper session management",
            "data_integrity": "Use HTTPS and implement proper data validation and checksums",
            "logging_failures": "Implement proper logging without exposing sensitive information",
            "ssrf": "Validate and restrict URLs, use allowlists for external requests",
            "xss_vulnerabilities": "Sanitize user inputs and use secure templating practices",
            "path_traversal": "Validate file paths and use secure file handling methods",
            "information_disclosure": "Remove debug information and implement proper error handling",
            "insufficient_logging": "Implement comprehensive logging for security events",
            "dangerous_function": "Replace dangerous functions with secure alternatives"
        }
        
        return recommendations.get(vuln_type, "Review and fix this security issue following security best practices")
    
    def _calculate_security_metrics(self, vulnerabilities: List[SecurityVulnerability], total_files: int) -> SecurityMetrics:
        """セキュリティメトリクス計算"""
        severity_counts = Counter(vuln.severity for vuln in vulnerabilities)
        
        # Calculate security score (0-100)
        total_vulns = len(vulnerabilities)
        if total_vulns == 0:
            security_score = 100.0
        else:
            # Weight severities: critical=4, high=3, medium=2, low=1, info=0.5
            weighted_score = (
                severity_counts.get('critical', 0) * 4 +
                severity_counts.get('high', 0) * 3 +
                severity_counts.get('medium', 0) * 2 +
                severity_counts.get('low', 0) * 1 +
                severity_counts.get('info', 0) * 0.5
            )
            
            # Normalize to 0-100 scale
            max_possible_score = total_files * 2  # Assume max 2 critical issues per file
            security_score = max(0, 100 - (weighted_score / max_possible_score * 100))
        
        # Determine compliance status
        if security_score >= 90:
            compliance_status = "excellent"
        elif security_score >= 75:
            compliance_status = "good"
        elif security_score >= 60:
            compliance_status = "acceptable"
        elif security_score >= 40:
            compliance_status = "poor"
        else:
            compliance_status = "critical"
        
        return SecurityMetrics(
            total_files_scanned=total_files,
            total_vulnerabilities=total_vulns,
            critical_count=severity_counts.get('critical', 0),
            high_count=severity_counts.get('high', 0),
            medium_count=severity_counts.get('medium', 0),
            low_count=severity_counts.get('low', 0),
            info_count=severity_counts.get('info', 0),
            security_score=round(security_score, 2),
            compliance_status=compliance_status
        )
    
    def _assess_owasp_compliance(self, vulnerabilities: List[SecurityVulnerability]) -> Dict[str, Any]:
        """OWASP準拠性評価"""
        owasp_categories = {
            "A01_Broken_Access_Control": ["broken_access_control"],
            "A02_Cryptographic_Failures": ["weak_cryptography"],
            "A03_Injection": ["sql_injection", "command_injection"],
            "A04_Insecure_Design": ["insecure_design"],
            "A05_Security_Misconfiguration": ["security_misconfiguration"],
            "A06_Vulnerable_Components": ["vulnerable_components"],
            "A07_Authentication_Failures": ["authentication_failures"],
            "A08_Data_Integrity_Failures": ["data_integrity"],
            "A09_Logging_Failures": ["logging_failures", "insufficient_logging"],
            "A10_SSRF": ["ssrf"]
        }
        
        compliance_results = {}
        
        for owasp_category, vuln_types in owasp_categories.items():
            category_vulns = [v for v in vulnerabilities if v.vulnerability_type in vuln_types]
            critical_high_count = len([v for v in category_vulns if v.severity in ['critical', 'high']])
            
            if critical_high_count == 0:
                status = "compliant"
                risk_level = "low"
            elif critical_high_count <= 2:
                status = "needs_attention"
                risk_level = "medium"
            else:
                status = "non_compliant"
                risk_level = "high"
            
            compliance_results[owasp_category] = {
                "status": status,
                "risk_level": risk_level,
                "vulnerability_count": len(category_vulns),
                "critical_high_count": critical_high_count
            }
        
        return compliance_results
    
    def _generate_security_recommendations(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """セキュリティ推奨事項生成"""
        recommendations = []
        vulnerabilities = scan_results["vulnerabilities"]
        metrics = scan_results["metrics"]
        
        # Critical vulnerabilities
        critical_vulns = [v for v in vulnerabilities if v.severity == "critical"]
        if critical_vulns:
            recommendations.append({
                "category": "critical_security_fixes",
                "priority": "immediate",
                "issue_count": len(critical_vulns),
                "description": f"{len(critical_vulns)} critical security vulnerabilities require immediate attention",
                "action_plan": [
                    "Fix all SQL injection and command injection vulnerabilities",
                    "Replace dangerous functions (eval, exec) with secure alternatives",
                    "Implement proper input validation and sanitization",
                    "Conduct security code review"
                ],
                "timeline": "Within 24 hours"
            })
        
        # Authentication and access control
        auth_vulns = [v for v in vulnerabilities if v.vulnerability_type in ["broken_access_control", "authentication_failures"]]
        if auth_vulns:
            recommendations.append({
                "category": "authentication_hardening",
                "priority": "high",
                "issue_count": len(auth_vulns),
                "description": "Authentication and access control vulnerabilities detected",
                "action_plan": [
                    "Implement proper authentication decorators on all protected routes",
                    "Add role-based access control (RBAC)",
                    "Implement session timeout and secure session management",
                    "Add multi-factor authentication for admin accounts"
                ],
                "timeline": "Within 1 week"
            })
        
        # Cryptographic improvements
        crypto_vulns = [v for v in vulnerabilities if v.vulnerability_type == "weak_cryptography"]
        if crypto_vulns:
            recommendations.append({
                "category": "cryptographic_improvements",
                "priority": "high",
                "issue_count": len(crypto_vulns),
                "description": "Weak cryptographic implementations detected",
                "action_plan": [
                    "Replace MD5 and SHA1 with SHA-256 or better",
                    "Use bcrypt for password hashing",
                    "Implement proper key management",
                    "Remove hardcoded secrets and use environment variables"
                ],
                "timeline": "Within 2 weeks"
            })
        
        # Security configuration
        config_vulns = [v for v in vulnerabilities if v.vulnerability_type == "security_misconfiguration"]
        if config_vulns:
            recommendations.append({
                "category": "security_configuration",
                "priority": "medium",
                "issue_count": len(config_vulns),
                "description": "Security misconfigurations detected",
                "action_plan": [
                    "Disable debug mode in production",
                    "Configure proper CORS policies",
                    "Enable SSL/TLS verification",
                    "Implement security headers"
                ],
                "timeline": "Within 1 week"
            })
        
        # General security improvements
        if metrics.security_score < 75:
            recommendations.append({
                "category": "overall_security_posture",
                "priority": "medium",
                "description": f"Overall security score is {metrics.security_score}/100",
                "action_plan": [
                    "Implement automated security scanning in CI/CD pipeline",
                    "Establish security code review processes",
                    "Create security awareness training for developers",
                    "Set up security monitoring and alerting",
                    "Conduct regular penetration testing"
                ],
                "timeline": "Ongoing"
            })
        
        return recommendations
    
    def run_comprehensive_security_scan(self) -> Dict[str, Any]:
        """包括的セキュリティスキャン実行"""
        print("🚀 CC02 v33.0 Security Vulnerability Scanner - Cycle 4")
        print("=" * 60)
        
        # Run vulnerability scan
        scan_results = self.scan_for_vulnerabilities()
        
        # Create comprehensive report
        comprehensive_report = {
            "scan_timestamp": datetime.now().isoformat(),
            "project_root": str(self.project_root),
            "scan_results": scan_results,
            "security_metrics": asdict(scan_results["metrics"]),
            "owasp_compliance": scan_results["owasp_compliance"],
            "recommendations": scan_results["recommendations"],
            "executive_summary": self._create_executive_summary(scan_results),
            "remediation_plan": self._create_remediation_plan(scan_results)
        }
        
        # Save report
        report_file = self.output_path / f"security_scan_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(comprehensive_report, f, indent=2, ensure_ascii=False, default=str)
        
        print(f"✅ Security scan complete! Report saved to: {report_file}")
        
        # Print summary
        self._print_security_summary(comprehensive_report)
        
        return comprehensive_report
    
    def _create_executive_summary(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """エグゼクティブサマリー作成"""
        metrics = scan_results["metrics"]
        vulnerabilities = scan_results["vulnerabilities"]
        
        # Top vulnerability types
        vuln_types = Counter(v.vulnerability_type for v in vulnerabilities)
        top_vulns = vuln_types.most_common(5)
        
        # Files with most vulnerabilities
        file_vulns = Counter(v.file_path for v in vulnerabilities)
        risky_files = file_vulns.most_common(10)
        
        return {
            "security_score": metrics.security_score,
            "compliance_status": metrics.compliance_status,
            "risk_level": "high" if metrics.critical_count > 0 else "medium" if metrics.high_count > 0 else "low",
            "total_vulnerabilities": metrics.total_vulnerabilities,
            "critical_issues": metrics.critical_count,
            "top_vulnerability_types": [{"type": vtype, "count": count} for vtype, count in top_vulns],
            "most_vulnerable_files": [{"file": file, "count": count} for file, count in risky_files],
            "immediate_actions_required": metrics.critical_count > 0 or metrics.high_count > 5
        }
    
    def _create_remediation_plan(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """修正計画作成"""
        vulnerabilities = scan_results["vulnerabilities"]
        
        # Group vulnerabilities by priority
        critical_vulns = [v for v in vulnerabilities if v.severity == "critical"]
        high_vulns = [v for v in vulnerabilities if v.severity == "high"]
        medium_vulns = [v for v in vulnerabilities if v.severity == "medium"]
        
        remediation_plan = []
        
        # Phase 1: Critical fixes
        if critical_vulns:
            remediation_plan.append({
                "phase": 1,
                "priority": "critical",
                "timeline": "24-48 hours",
                "vulnerabilities": len(critical_vulns),
                "focus_areas": list(set(v.vulnerability_type for v in critical_vulns)),
                "success_criteria": "Zero critical vulnerabilities remaining"
            })
        
        # Phase 2: High priority fixes
        if high_vulns:
            remediation_plan.append({
                "phase": 2,
                "priority": "high",
                "timeline": "1-2 weeks",
                "vulnerabilities": len(high_vulns),
                "focus_areas": list(set(v.vulnerability_type for v in high_vulns)),
                "success_criteria": "Reduce high-severity vulnerabilities by 80%"
            })
        
        # Phase 3: Medium priority fixes
        if medium_vulns:
            remediation_plan.append({
                "phase": 3,
                "priority": "medium",
                "timeline": "2-4 weeks",
                "vulnerabilities": len(medium_vulns),
                "focus_areas": list(set(v.vulnerability_type for v in medium_vulns)),
                "success_criteria": "Address all medium-severity vulnerabilities"
            })
        
        return remediation_plan
    
    def _print_security_summary(self, report: Dict[str, Any]):
        """セキュリティサマリー出力"""
        print("\n" + "=" * 60)
        print("🔒 Security Scan Summary")
        print("=" * 60)
        
        summary = report["executive_summary"]
        metrics = report["security_metrics"]
        
        print(f"Security Score: {summary['security_score']}/100 ({summary['compliance_status']})")
        print(f"Risk Level: {summary['risk_level'].upper()}")
        print(f"Files Scanned: {metrics['total_files_scanned']}")
        print(f"Total Vulnerabilities: {metrics['total_vulnerabilities']}")
        
        # Severity breakdown
        print(f"\n📊 Vulnerability Breakdown:")
        print(f"  Critical: {metrics['critical_count']}")
        print(f"  High: {metrics['high_count']}")
        print(f"  Medium: {metrics['medium_count']}")
        print(f"  Low: {metrics['low_count']}")
        
        # Top vulnerabilities
        print(f"\n🔥 Top Vulnerability Types:")
        for i, vuln_info in enumerate(summary["top_vulnerability_types"][:5], 1):
            print(f"  {i}. {vuln_info['type']}: {vuln_info['count']} occurrences")
        
        # OWASP compliance
        print(f"\n🛡️ OWASP Top 10 Compliance:")
        owasp_compliance = report["owasp_compliance"]
        non_compliant = [cat for cat, info in owasp_compliance.items() if info["status"] == "non_compliant"]
        needs_attention = [cat for cat, info in owasp_compliance.items() if info["status"] == "needs_attention"]
        
        if non_compliant:
            print(f"  ❌ Non-compliant: {len(non_compliant)} categories")
        if needs_attention:
            print(f"  ⚠️ Needs attention: {len(needs_attention)} categories")
        
        # Immediate actions
        if summary["immediate_actions_required"]:
            print(f"\n🚨 IMMEDIATE ACTION REQUIRED:")
            print(f"  - {metrics['critical_count']} critical vulnerabilities need immediate attention")
            print(f"  - Review and fix all SQL injection and command injection issues")
            print(f"  - Implement proper input validation and authentication")
        
        # Next steps
        print(f"\n📋 Next Steps:")
        remediation_plan = report["remediation_plan"]
        for phase in remediation_plan[:2]:
            print(f"  Phase {phase['phase']} ({phase['timeline']}): {phase['vulnerabilities']} {phase['priority']} issues")


def main():
    """メイン実行関数"""
    project_root = Path.cwd()
    
    print("🔬 CC02 v33.0 Security Vulnerability Scanner")
    print("=" * 60)
    print(f"Project root: {project_root}")
    
    scanner = SecurityVulnerabilityScanner(project_root)
    report = scanner.run_comprehensive_security_scan()
    
    return report


if __name__ == "__main__":
    main()